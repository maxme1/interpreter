program = statement*

statement = (StmtBody? DELIMITER) | ifStmt | whileStmt | forStmt | tryStmt
        | funcDef | classDef

StmtBody = expression | 'break' | 'continue' | returnStmt | raiseStmt | importStmt
returnStmt = 'return' expression?
raiseStmt = 'raise' expression?

importStmt = 'import' IDENTIFIER
tryStmt = 'try' argsValues? block ('catch' argsValues block)*
ifStmt = 'if' expression block ('else' block)?
whileStmt = 'while' expression block
forStmt = 'for' IDENTIFIER 'in' expression block
block = BLOCK_BEGIN statement* BLOCK_END

funcDef = 'def' IDENTIFIER arguments? block
arguments = '(' argsList? ')'
argsList = IDENTIFIER (SEPARATOR IDENTIFIER)*

classDef = 'class' IDENTIFIER superclass? block
superclass = EXTENDS expression

-- expression --

expression = logicOr | assignment

assignment = assignable | IDENTIFIER '=' expression
assignable = primary attribute | item

logicOr = logicAnd ( 'and' logicAnd )*
logicAnd = comparison ( 'and' comparison )*
comparison = term (( '==' | '>=' | '<=' | '<' | '>' | '!=' ) term )*
term = factor ( ('+' | '-') factor )*
factor = unary ( ('*' | '/' | 'not' ) unary )*
# TODO: maybe add unlimited unary operations
unary = ('+' | '-')? primary

primary = literal suffix*
literal = NUMBER | IDENTIFIER | BOOL | NONE | STRING | bracket
bracket = '(' expression ')'

suffix = call | attribute | item
attribute = '.' IDENTIFIER
item = '[' expression ']'
call = '(' argsValues? ')'
argsValues = expression (SEPARATOR expression)*

-- base definitions --

NUMBER = '\d+'
STRING = "'[^']*'"
BOOL = 'True' | 'False'
NONE = 'None'
IDENTIFIER = '[a-zA-Z_]\w*'
DELIMITER = '[;\n]'
SEPARATOR = ','
EXTENDS = 'extends'
COMMENT = '#[^\n]*'
BLOCK_BEGIN = `indent up`
BLOCK_END = `indent down`